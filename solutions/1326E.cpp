/*

题目：https://codeforces.com/contest/1326/problem/E
题解：https://codeforces.com/blog/entry/74961

看规模需要在 O(nlogn) 解决问题。

一般想正向模拟维护状态，每放入一个炸弹，以 O(logn) 的代价转移状态，然后求解。
但实际上加入一个炸弹对前序状态影响太大，找不到 O(logn) 转移状态的方式，需要转变思路。

注意到每加入一个炸弹，情况一定变得更糟，则一定有 ans[i]<=ans[i-1]。
由于 ans 最大为 n，可以从 x=n 开始，每加入一个炸弹，则尝试验证 x 能不能成为解，如果不能则 x-- 继续验证。

为了找到验证的方法，我们假设加入 k 个炸弹后，答案 <=x，则 >x 的数字被全部炸出。
要达成这种情况，最后的炸弹分布一定是(充要条件)：
1. 从右往左看，最后一个 >x 的数字右边(包括它的位置)至少有 1 个炸弹
2. 从右往左看，倒数第二 >x 的数字右边(包括它的位置)至少有 2 个炸弹
...
充要条件证明：1）达成这种情况，>x 的数一定全被炸出，2）要让 >x 的数全被炸出，至少需要出现这种情况。
有了这个充要条件，每加入一个炸弹，让 x=n 开始，验证这个条件，复杂度为 O(n^2)。

为了更快的完成验证，我们维护数组 b[i] 表示 (i...n 后缀 >x 数个数)-(i...n 后缀炸弹个数)。
可见上述情况成立的充要条件为：对所有 i 有 b[i]<=0，该条件成立则说明解一定 <=x。

由于 ans 是不递增的，我们可以让 x=n 开始，随着加入炸弹开始验证并递减，在状态转移上：
1. 每减少一次 x 的值，则相当于让 [1, pos[x]] 区间全部 b 值加一
2. 每加入一个炸弹，则相当于让 [1, q[k]] 区间全部 b 值减一
3. 询问所有 i 有 b[i]<=0，则相当于询问 max(b[[1, n]])<=0
上面的一切状态操作都可以用线段树完成。

*/